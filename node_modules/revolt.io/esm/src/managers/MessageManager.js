import { BaseManager } from './BaseManager.js';
import { TypeError } from '../errors/mod.js';
import { Message } from '../structures/mod.js';
import { Collection, UUID } from '../util/mod.js';
export class MessageManager extends BaseManager {
    constructor(channel) {
        super(channel.client);
        Object.defineProperty(this, "channel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: channel
        });
        Object.defineProperty(this, "holds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Message
        });
    }
    async send(content) {
        if (typeof content === 'string')
            content = { content };
        const data = await this.client.api.post(`/channels/${this.channel.id}/messages`, {
            body: { ...content, nonce: UUID.generate() },
        });
        return this._add(data);
    }
    async ack(message) {
        const id = this.resolveId(message);
        if (!id) {
            throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');
        }
        await this.client.api.put(`/channels/${this.channel.id}/ack/${id}`);
    }
    async bulkDelete(messages) {
        let ids = [];
        if (typeof messages === 'number') {
            messages = await this.fetch(messages);
            ids = [...messages.keys()];
        }
        else if (messages instanceof Collection) {
            ids = [...messages.keys()];
        }
        else {
            ids = messages.map((m) => this.resolveId(m)).filter(Boolean);
        }
        await this.client.api.delete(`/channels/${this.channel.id}/messages/bulk`, {
            body: { ids },
        });
    }
    async delete(message) {
        const id = this.resolveId(message);
        if (!id) {
            throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');
        }
        await this.client.api.delete(`/channels/${this.channel.id}/messages/${id}`);
    }
    async edit(message, options) {
        const id = this.resolveId(message);
        if (!id) {
            throw new TypeError('INVALID_TYPE', 'message', 'MessageResolvable');
        }
        if (typeof options === 'string')
            options = { content: options };
        await this.client.api.patch(`/channels/${this.channel.id}/messages/${id}`, {
            body: options,
        });
    }
    async search(query) {
        if (typeof query === 'string')
            query = { query };
        const response = await this.client.api.post(`/channels/${this.channel.id}/search`, {
            query: query,
        });
        return response.reduce((coll, cur) => {
            const msg = this._add(cur);
            coll.set(msg.id, msg);
            return coll;
        }, new Collection());
    }
    async fetch(query) {
        const id = this.resolveId(query);
        if (id) {
            const data = await this.client.api.get(`/channels/${this.channel.id}/messages/${id}`);
            return this._add(data);
        }
        if (typeof query === 'number')
            query = { limit: query };
        else if (typeof query === 'undefined')
            query = { limit: 100 };
        const messages = await this.client.api.get(`/channels/${this.channel.id}/messages`, { query: query });
        return messages.reduce((coll, cur) => {
            const msg = this._add(cur);
            coll.set(msg.id, msg);
            return coll;
        }, new Collection());
    }
}
