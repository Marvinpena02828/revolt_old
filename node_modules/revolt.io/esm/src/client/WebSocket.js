// deno-lint-ignore-file no-explicit-any
import * as dntShim from "../../_dnt.shims.js";
import { ClientUser } from '../structures/mod.js';
import { Events, WSEvents } from '../util/mod.js';
import { Error } from '../errors/mod.js';
export class WebSocketShard {
    constructor(client) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: client
        });
        Object.defineProperty(this, "heartbeatInterval", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastPingTimestamp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastPongAcked", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "socket", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "connected", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "ready", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "reconnecting", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
    }
    debug(message) {
        this.client.emit(Events.DEBUG, `[WS]: ${message}`);
    }
    async send(data) {
        if (this.reconnecting) {
            this.debug('Waiting reconnecting...');
            await this.reconnecting;
        }
        if (this.socket?.readyState === dntShim.WebSocket.OPEN) {
            this.socket.send(JSON.stringify(data));
        }
        else {
            this.debug(`Tried to send packet '${JSON.stringify(data)}' but no WebSocket is available!`);
        }
    }
    onOpen() {
        if (!this.client.token)
            throw new Error('INVALID_TOKEN');
        this.send({
            type: WSEvents.AUTHENTICATE,
            token: this.client.token,
        });
    }
    get ping() {
        if (!this.lastPingTimestamp)
            return -0;
        return Date.now() - this.lastPingTimestamp;
    }
    setHeartbeatTimer(time) {
        this.debug(`Setting a heartbeat interval for ${time}ms.`);
        if (this.heartbeatInterval)
            clearInterval(this.heartbeatInterval);
        if (time !== -1) {
            this.heartbeatInterval = setInterval(() => this.sendHeartbeat(), time);
        }
    }
    sendHeartbeat() {
        this.debug('Sending a heartbeat.');
        if (!this.lastPongAcked) {
            this.debug('Did not receive a pong ack last time.');
            if (this.client.options.ws.reconnect) {
                this.debug('Reconnecting...');
                this.reconnecting = this.destroy().then(() => this.connect()).then(() => this.reconnecting = null);
            }
        }
        const now = Date.now();
        this.send({ type: WSEvents.PING, data: now });
        this.lastPongAcked = false;
        this.lastPingTimestamp = now;
    }
    onError(event) {
        this.client.emit(Events.ERROR, event);
    }
    onMessage({ data }) {
        let packet;
        try {
            packet = JSON.parse(String(data));
        }
        catch (err) {
            this.client.emit(Events.ERROR, err);
            return;
        }
        this.client.emit(Events.RAW, packet);
        this.onPacket(packet).catch((e) => this.client.emit(Events.ERROR, e));
    }
    onClose(event) {
        this.debug(`Closed with reason: ${event.reason}, code: ${event.code}`);
        this.destroy();
    }
    async onPacket(packet) {
        if (!packet) {
            this.debug(`Received broken packet: '${packet}'.`);
            return;
        }
        switch (packet.type) {
            case WSEvents.BULK:
                await Promise.all(packet.v.map((p) => this.onPacket(p)));
                break;
            case WSEvents.AUTHENTICATED:
                this.connected = true;
                break;
            case WSEvents.PONG:
                this.debug(`Received a heartbeat.`);
                this.lastPongAcked = true;
                break;
            case WSEvents.ERROR:
                this.client.emit(Events.ERROR, packet.error);
                break;
            case WSEvents.READY: {
                this.lastPongAcked = true;
                const promises = [];
                for (const user of packet.users) {
                    if (user.relationship === 'User' && !this.client.user) {
                        this.client.user = new ClientUser(this.client, user);
                    }
                    else {
                        this.client.users._add(user);
                    }
                }
                for (const server of packet.servers) {
                    const s = this.client.servers._add(server);
                    if (this.client.options.fetchMembers) {
                        promises.push(s.members.fetch());
                    }
                }
                for (const channel of packet.channels) {
                    this.client.channels._add(channel);
                }
                for (const member of packet.members) {
                    this.client.servers.cache.get(member._id.server)?.members._add(member);
                }
                this.setHeartbeatTimer(this.client.options.ws.heartbeat);
                await Promise.all(promises);
                this.ready = true;
                this.client.emit(Events.READY, this.client);
                break;
            }
            default: {
                const action = this.client.actions.get(packet.type);
                if (action) {
                    await action.handle(packet);
                }
                else {
                    this.debug(`Received unknown packet "${packet.type}"`);
                }
                break;
            }
        }
    }
    connect() {
        return new Promise((resolve) => {
            if (this.socket?.readyState === dntShim.WebSocket.OPEN && this.ready) {
                return resolve(this);
            }
            if (typeof this.client.configuration === 'undefined') {
                throw new Error('MISSING_CONFIGURATION_SYNC');
            }
            if (typeof this.client.token !== 'string') {
                throw new Error('INVALID_TOKEN');
            }
            const ws = (this.socket = this.socket ??
                new dntShim.WebSocket(this.client.configuration.ws));
            ws.onopen = this.onOpen.bind(this);
            ws.onmessage = this.onMessage.bind(this);
            ws.onerror = this.onError.bind(this);
            ws.onclose = this.onClose.bind(this);
            ws.addEventListener('open', () => resolve(this));
        });
    }
    destroy() {
        return new Promise((resolve) => {
            this.setHeartbeatTimer(-1);
            this.connected = false;
            this.ready = false;
            if (this.socket?.readyState === dntShim.WebSocket.OPEN) {
                this.socket.addEventListener('close', () => {
                    this.socket = null;
                    resolve();
                });
                this.socket.close();
            }
            else {
                this.socket = null;
                resolve();
            }
        });
    }
}
