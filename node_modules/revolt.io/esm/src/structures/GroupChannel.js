import { Attachment, Channel, Invite } from './mod.js';
import { TypeError } from '../errors/mod.js';
import { MessageManager, } from '../managers/mod.js';
import { ChannelPermissions, ChannelTypes, Collection } from '../util/mod.js';
export class GroupChannel extends Channel {
    constructor(client, data) {
        super(client);
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ChannelTypes.GROUP
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "ownerId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "permissions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "icon", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "messages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new MessageManager(this)
        });
        Object.defineProperty(this, "lastMessageId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "users", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Collection()
        });
        Object.defineProperty(this, "nsfw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        this._patch(data);
    }
    _patch(data) {
        super._patch(data);
        if ('description' in data) {
            this.description = data.description ?? null;
        }
        if (Array.isArray(data.recipients)) {
            this.users.clear();
            for (const userId of data.recipients) {
                const user = this.client.users.cache.get(userId);
                if (user)
                    this.users.set(user.id, user);
            }
        }
        if (typeof data.permissions === 'number') {
            this.permissions = new ChannelPermissions(data.permissions).freeze();
        }
        if (data.owner) {
            this.ownerId = data.owner;
        }
        if (data.icon) {
            this.icon = new Attachment(this.client, data.icon);
        }
        if (data.name) {
            this.name = data.name;
        }
        if (data.last_message_id)
            this.lastMessageId = data.last_message_id;
        if (typeof data.nsfw === 'boolean')
            this.nsfw = data.nsfw;
        return this;
    }
    get lastMessage() {
        if (!this.lastMessageId)
            return null;
        return this.messages.cache.get(this.lastMessageId) ?? null;
    }
    get owner() {
        return this.client.users.cache.get(this.ownerId) ?? null;
    }
    bulkDelete(messages) {
        return this.messages.bulkDelete(messages);
    }
    async createInvite() {
        const data = await this.client.api.post(`/channels/${this.id}/invites`);
        return new Invite(this.client, data);
    }
    async add(user) {
        const id = this.client.users.resolveId(user);
        if (!id)
            throw new TypeError('INVALID_TYPE', 'user', 'UserResolvable');
        await this.client.api.put(`/channels/${this.id}/recipients/${id}`);
    }
    async remove(user) {
        const id = this.client.users.resolveId(user);
        if (!id)
            throw new TypeError('INVALID_TYPE', 'user', 'UserResolvable');
        await this.client.api.delete(`/channels/${this.id}/recipients/${id}`);
    }
    leave() {
        return super.delete();
    }
    send(options) {
        return this.messages.send(options);
    }
    iconURL(options) {
        if (!this.icon)
            return null;
        return this.client.api.cdn.icon(this.icon.id, options?.size);
    }
}
